{
    "solved_by": "two iterations agent",
    "enriched_column_names": [
        "adjusted_annual_income",
        "income_level",
        "loan_to_income_ratio",
        "default_risk_by_region",
        "total_loan_amount",
        "marital_status_risk",
        "employment_status_risk",
        "gender_risk",
        "customer_loan_count",
        "employment_default_proportion",
        "customer_age",
        "loan_term_classification",
        "interest_rate_tier",
        "yearly_default_rate"
    ],
    "solution_type": "SolutionType.FeatureEngineering",
    "new_feature_functions": [],
    "sorted_feature_functions": {
        "0.5702611529954303": {
            "name": "adjusted_annual_income",
            "code": "\n\ndef adjusted_annual_income(row, aux_data: Dict[str, pd.DataFrame]):\n    # Extract the customer demographics dataframe from aux_data\n    customer_demographics = aux_data['customer_demographics_table.csv']\n    \n    # Find the customer_id in the customer demographics table\n    customer_id = row['customer_id']\n    customer_data = customer_demographics[customer_demographics['customer_id'] == customer_id]\n    \n    # If the customer_id is not found, return None or a default value\n    if customer_data.empty:\n        return None\n    \n    # Extract the required fields\n    date_of_birth = customer_data.iloc[0]['date_of_birth']\n    annual_income = customer_data.iloc[0]['annual_income']\n    \n    # Calculate the adjusted annual income\n    inflation_rate = 0.03  # Assuming a 3% inflation rate\n    current_year = 2023\n    birth_year = int(date_of_birth.split('-')[0])\n    years_working = max(0, current_year - birth_year - 18)\n    adjusted_income = annual_income * ((1 + inflation_rate) ** (years_working / 10))\n    \n    return adjusted_income\n"
        },
        "0.3460940407119809": {
            "name": "income_level",
            "code": "\n\ndef income_level(row, aux_data: Dict[str, pd.DataFrame]):\n    # Get the customer demographics dataframe\n    customer_demographics = aux_data['customer_demographics_table.csv']\n    \n    # Find the customer's annual income using the customer_id\n    customer_id = row['customer_id']\n    customer_data = customer_demographics[customer_demographics['customer_id'] == customer_id]\n    \n    # Check if the customer exists in the demographics table\n    if not customer_data.empty:\n        annual_income = customer_data.iloc[0]['annual_income']\n        \n        # Determine income level based on annual income\n        if annual_income >= 150000:\n            return \"High\"\n        elif annual_income >= 75000:\n            return \"Medium\"\n        else:\n            return \"Low\"\n    else:\n        # If customer_id is not found, return None or a default value\n        return None\n"
        },
        "0.2525167757112373": {
            "name": "loan_to_income_ratio",
            "code": "import pandas as pd\n\ndef loan_to_income_ratio(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Use the correct key to access the payment history dataframe\n    payment_history_df = aux_dataframes.get(\"payment_history_table.csv\")\n    customer_demographics_df = aux_dataframes.get(\"customer_demographics_table.csv\")\n    \n    # Check if the required dataframes are present\n    if payment_history_df is None:\n        raise KeyError(\"The key 'payment_history_table.csv' is missing in aux_dataframes.\")\n    if customer_demographics_df is None:\n        raise KeyError(\"The key 'customer_demographics_table.csv' is missing in aux_dataframes.\")\n    \n    # Ensure the payment history dataframe has the required columns\n    if 'loan_application_id' not in payment_history_df.columns:\n        raise KeyError(\"The 'payment_history_table.csv' dataframe is missing the required column 'loan_application_id'.\")\n    \n    # Ensure the customer demographics dataframe has the required columns\n    if 'customer_id' not in customer_demographics_df.columns or 'annual_income' not in customer_demographics_df.columns:\n        raise KeyError(\"The 'customer_demographics_table.csv' dataframe is missing the required columns 'customer_id' or 'annual_income'.\")\n    \n    # Get the customer_id from the current row\n    customer_id = row.get('customer_id')\n    if customer_id is None:\n        raise ValueError(\"The row is missing the 'customer_id' column.\")\n    \n    # Retrieve the annual income for the customer\n    customer_data = customer_demographics_df.loc[customer_demographics_df['customer_id'] == customer_id]\n    if customer_data.empty:\n        raise ValueError(f\"No matching customer data found for customer_id {customer_id}.\")\n    \n    annual_income = customer_data['annual_income'].values[0]\n    if pd.isnull(annual_income) or annual_income == 0:\n        raise ValueError(f\"The annual income for customer_id {customer_id} is missing or 0.\")\n    \n    # Retrieve the loan amount from the current row\n    loan_amount = row.get('loan_amount')\n    if loan_amount is None or pd.isnull(loan_amount) or loan_amount == 0:\n        raise ValueError(f\"The loan amount for loan_application_id {row.get('loan_application_id')} is missing or 0.\")\n    \n    # Calculate and return the loan-to-income ratio\n    return loan_amount / annual_income\n"
        },
        "0.14228616669081678": {
            "name": "default_risk_by_region",
            "code": "\n\ndef default_risk_by_region(row, df_train: pd.DataFrame, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Access the customer demographics dataframe\n    customer_demographics = aux_dataframes[\"customer_demographics_table.csv\"]\n    \n    # Merge the training dataframe with customer demographics to get the region information\n    merged_df = df_train.merge(customer_demographics, on=\"customer_id\", how=\"left\")\n    \n    # Filter out rows with application dates later than the current row's application date\n    filtered_df = merged_df[merged_df[\"application_date\"] <= row[\"application_date\"]]\n    \n    # Exclude the current row from the calculation to prevent target leakage\n    filtered_df = filtered_df[filtered_df[\"loan_application_id\"] != row[\"loan_application_id\"]]\n    \n    # Calculate the default ratio by region\n    region_default_ratio = (\n        filtered_df.groupby(\"region\")[\"DefaultStatus\"]\n        .mean()\n        .to_dict()\n    )\n    \n    # Get the region of the current row\n    region = customer_demographics.loc[\n        customer_demographics[\"customer_id\"] == row[\"customer_id\"], \"region\"\n    ].values[0]\n    \n    # Get the default risk for the region, defaulting to 0 if the region is not found\n    region_default_risk = region_default_ratio.get(region, 0)\n    \n    return region_default_risk\n"
        },
        "0.038639493051951926": {
            "name": "total_loan_amount",
            "code": "\n\ndef total_loan_amount(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Ensure the correct key is used for the payment history table\n    payment_history_df = aux_dataframes.get(\"payment_history_table.csv\")\n    \n    if payment_history_df is None:\n        raise KeyError(\"The key 'payment_history_table.csv' is missing from aux_dataframes.\")\n    \n    # Check if the necessary columns exist in the payment history dataframe\n    if 'loan_application_id' not in payment_history_df.columns:\n        raise KeyError(\"The required column 'loan_application_id' is missing from the payment history dataframe.\")\n    \n    # Filter the payment history dataframe for the given loan_application_id\n    customer_loans = payment_history_df[payment_history_df['loan_application_id'] == row['loan_application_id']]\n    \n    # Calculate the total loan amount for the customer\n    # Since the payment history table does not have loan amounts, we assume the total loan amount\n    # is the sum of the 'loan_amount' column in the main dataframe for the matching loan_application_id\n    total_loans = row['loan_amount'] if not customer_loans.empty else 0\n    \n    return total_loans\n"
        },
        "0.016793916242305595": {
            "name": "marital_status_risk",
            "code": "\n\ndef marital_status_risk(row, df_train: pd.DataFrame, aux_data: Dict[str, pd.DataFrame]):\n    \"\"\"\n    Calculate the marital status risk for a given row without introducing target leakage or using future data.\n    \n    Args:\n        row (pd.Series): The row of the dataframe for which the risk is being calculated.\n        df_train (pd.DataFrame): The training dataframe containing historical loan data.\n        aux_data (Dict[str, pd.DataFrame]): A dictionary containing auxiliary data, including customer demographics.\n    \n    Returns:\n        float: The calculated marital status risk for the given row.\n    \"\"\"\n    # Extract the customer demographics table from aux_data\n    customer_demographics = aux_data.get('customer_demographics_table.csv')\n    \n    # Ensure the required table exists and contains the necessary columns\n    if customer_demographics is None or 'marital_status' not in customer_demographics or 'customer_id' not in customer_demographics:\n        raise ValueError(\"The required 'customer_demographics_table.csv' is missing or does not contain the necessary columns.\")\n    \n    # Merge df_train with customer_demographics to get marital_status and DefaultStatus together\n    merged_data = df_train.merge(customer_demographics[['customer_id', 'marital_status']], on='customer_id', how='left')\n    \n    # Filter out rows with application_date >= the current row's application_date (to prevent future data usage)\n    historical_data = merged_data[merged_data['application_date'] < row['application_date']]\n    \n    # Calculate the mean DefaultStatus for each marital_status using only historical data\n    marital_risks = historical_data.groupby(\"marital_status\")[\"DefaultStatus\"].mean()\n    \n    # Get the marital_status of the current row\n    marital_status = customer_demographics.loc[customer_demographics['customer_id'] == row['customer_id'], 'marital_status']\n    \n    # If marital_status is not found, return 0\n    if marital_status.empty:\n        return 0\n    \n    # Return the risk for the marital_status, defaulting to 0 if not found\n    return marital_risks.get(marital_status.iloc[0], 0)\n"
        },
        "0.01612261709450792": {
            "name": "employment_status_risk",
            "code": "import pandas as pd\n\ndef employment_status_risk(row, df_train: pd.DataFrame, aux_data: Dict[str, pd.DataFrame]):\n    import pandas as pd\n\n    # Ensure the required auxiliary data is present\n    if 'customer_demographics_table.csv' not in aux_data:\n        raise ValueError(\"The required 'customer_demographics_table.csv' is missing in aux_data.\")\n    \n    customer_demographics = aux_data['customer_demographics_table.csv']\n    \n    # Check if 'employment_status' exists in the customer_demographics DataFrame\n    if 'employment_status' not in customer_demographics.columns:\n        raise KeyError(\"'employment_status' column is missing in the customer_demographics_table.csv file.\")\n    \n    # Merge df_train with customer_demographics to get the 'employment_status' for each row\n    # Perform the merge only once for efficiency\n    if 'employment_status' not in df_train.columns:\n        df_train = df_train.merge(customer_demographics[['customer_id', 'employment_status']], on='customer_id', how='left')\n    \n    # Filter the training data to include only rows with earlier application dates\n    historical_data = df_train[df_train['application_date'] < row['application_date']]\n    \n    # Calculate the mean DefaultStatus for each employment_status using only historical data\n    employment_risks = historical_data.groupby(\"employment_status\")[\"DefaultStatus\"].mean()\n    \n    # Get the employment_status for the current row\n    employment_status = customer_demographics.loc[\n        customer_demographics['customer_id'] == row['customer_id'], 'employment_status'\n    ].values\n    \n    # If employment_status is found, return the corresponding risk; otherwise, return 0\n    if len(employment_status) > 0:\n        return employment_risks.get(employment_status[0], 0)\n    else:\n        return 0\n"
        },
        "0.014559582170109107": {
            "name": "gender_risk",
            "code": "import pandas as pd\n\ndef gender_risk(row, df_train: pd.DataFrame, aux_data: Dict[str, pd.DataFrame]):\n    \"\"\"\n    Calculate the gender risk for a given row based on historical data, \n    while preventing target leakage and ensuring no data from the future is used.\n    \n    Args:\n        row (pd.Series): The row of the DataFrame being processed.\n        df_train (pd.DataFrame): The training DataFrame containing historical loan data.\n        aux_data (Dict[str, pd.DataFrame]): Auxiliary data, including customer demographics.\n    \n    Returns:\n        float: The gender risk for the given row.\n    \"\"\"\n    # Ensure the required auxiliary data is present\n    if \"customer_demographics_table.csv\" in aux_data:\n        demographics_df = aux_data[\"customer_demographics_table.csv\"]\n        \n        # Check if the required columns exist in the respective DataFrames\n        if \"gender\" in demographics_df.columns and \"DefaultStatus\" in df_train.columns and \"customer_id\" in df_train.columns:\n            # Merge df_train with demographics_df on customer_id to include the gender column\n            merged_df = df_train.merge(demographics_df[['customer_id', 'gender']], on='customer_id', how='left')\n            \n            # Filter out rows with application dates in the future relative to the current row\n            current_application_date = pd.to_datetime(row['application_date'])\n            historical_data = merged_df[pd.to_datetime(merged_df['application_date']) < current_application_date]\n            \n            # Exclude the current row from the historical data to prevent target leakage\n            historical_data = historical_data[historical_data['loan_application_id'] != row['loan_application_id']]\n            \n            # Calculate gender risks based on historical data\n            gender_risks = historical_data.groupby(\"gender\")[\"DefaultStatus\"].mean()\n            \n            # Get the gender for the current row\n            customer_id = row['customer_id']\n            gender = demographics_df.loc[demographics_df['customer_id'] == customer_id, 'gender']\n            \n            # If gender is found, return the corresponding risk; otherwise, return 0\n            if not gender.empty:\n                return gender_risks.get(gender.iloc[0], 0)\n            else:\n                return 0\n        else:\n            raise KeyError(\"Required columns 'gender', 'DefaultStatus', or 'customer_id' are missing in the provided DataFrames.\")\n    else:\n        raise KeyError(\"'customer_demographics_table.csv' is missing in aux_data.\")\n"
        },
        "0.0111565852997619": {
            "name": "customer_loan_count",
            "code": "\n\ndef customer_loan_count(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Access the payment history dataframe\n    payment_history = aux_dataframes[\"payment_history_table.csv\"]\n    \n    # Access the customer demographics dataframe\n    customer_demographics = aux_dataframes[\"customer_demographics_table.csv\"]\n    \n    # Ensure the customer_id column exists in both DataFrames\n    if 'customer_id' not in customer_demographics.columns:\n        raise KeyError(\"'customer_id' not found in customer_demographics_table.csv\")\n    \n    # Merge payment history with customer demographics to associate customer_id with payment history\n    merged_data = payment_history.merge(\n        customer_demographics[['customer_id']],\n        left_on='payment_id',  # Assuming payment_id is the key to link with customer_id\n        right_index=True,  # Use the index of customer_demographics\n        how='inner'\n    )\n    \n    # Filter the merged data for the given customer_id\n    loans = merged_data.loc[merged_data['customer_id'] == row['customer_id']]\n    \n    # Return the count of loans for the customer\n    return loans.shape[0]\n"
        },
        "0.008535927507593747": {
            "name": "employment_default_proportion",
            "code": "\n\ndef employment_default_proportion(row, df_train: pd.DataFrame, aux_data: Dict[str, pd.DataFrame]):\n    \"\"\"\n    Calculate the proportion of defaults for the employment status of the customer in the current row,\n    while preventing target leakage and ensuring no future data is used.\n    \n    Args:\n        row (pd.Series): The current row of the DataFrame being processed.\n        df_train (pd.DataFrame): The training DataFrame containing loan application data.\n        aux_data (Dict[str, pd.DataFrame]): A dictionary containing auxiliary data, including customer demographics.\n    \n    Returns:\n        float: The proportion of defaults for the customer's employment status.\n    \"\"\"\n    # Ensure the required auxiliary data is present\n    if 'customer_demographics_table.csv' not in aux_data:\n        raise ValueError(\"The required 'customer_demographics_table.csv' is missing from aux_data.\")\n    \n    customer_demographics = aux_data['customer_demographics_table.csv']\n    \n    # Ensure the required columns are present in the dataframes\n    if 'customer_id' not in df_train.columns or 'customer_id' not in customer_demographics.columns:\n        raise ValueError(\"'customer_id' column is missing in one of the DataFrames.\")\n    if 'employment_status' not in customer_demographics.columns:\n        raise ValueError(\"'employment_status' column is missing in the customer_demographics DataFrame.\")\n    if 'DefaultStatus' not in df_train.columns:\n        raise ValueError(\"'DefaultStatus' column is missing in the df_train DataFrame.\")\n    if 'application_date' not in df_train.columns:\n        raise ValueError(\"'application_date' column is missing in the df_train DataFrame.\")\n    \n    # Merge df_train with customer_demographics to include 'employment_status'\n    merged_df = df_train.merge(customer_demographics[['customer_id', 'employment_status']], on='customer_id', how='left')\n    \n    # Check if the merge was successful and 'employment_status' exists\n    if 'employment_status' not in merged_df.columns:\n        raise KeyError(\"'employment_status' column is missing after merging.\")\n    \n    # Get the current row's customer_id and application_date\n    customer_id = row['customer_id']\n    application_date = row['application_date']\n    \n    # Get the employment_status for the current row\n    employment_status = customer_demographics.loc[customer_demographics['customer_id'] == customer_id, 'employment_status']\n    \n    # If employment_status is not found, return 0\n    if employment_status.empty:\n        return 0\n    \n    employment_status = employment_status.iloc[0]\n    \n    # Filter the merged_df to include only rows with application_date <= current row's application_date\n    # This ensures no future data is used\n    filtered_df = merged_df[merged_df['application_date'] <= application_date]\n    \n    # Exclude the current row from the calculation to prevent target leakage\n    filtered_df = filtered_df[filtered_df['customer_id'] != customer_id]\n    \n    # Group by 'employment_status' and calculate the mean of 'DefaultStatus'\n    employment_defaults = filtered_df.groupby(\"employment_status\")[\"DefaultStatus\"].mean()\n    \n    # Get the default proportion for the employment_status\n    return employment_defaults.get(employment_status, 0)\n"
        },
        "0.005799827295797229": {
            "name": "customer_age",
            "code": "\n\ndef customer_age(row, aux_data: Dict[str, pd.DataFrame]):\n    # Extract the customer_id from the row\n    customer_id = row['customer_id']\n    \n    # Get the customer demographics dataframe from aux_data\n    customer_demographics_df = aux_data['customer_demographics_table.csv']\n    \n    # Find the row in the customer demographics dataframe that matches the customer_id\n    customer_row = customer_demographics_df[customer_demographics_df['customer_id'] == customer_id]\n    \n    # If the customer_id is not found, return None\n    if customer_row.empty:\n        return None\n    \n    # Extract the date_of_birth for the customer\n    date_of_birth = customer_row.iloc[0]['date_of_birth']\n    \n    # Calculate the birth year\n    birth_year = int(date_of_birth.split('-')[0])\n    \n    # Define the current year\n    current_year = 2023\n    \n    # Calculate and return the age\n    return current_year - birth_year\n"
        },
        "-0.0008663164959530345": {
            "name": "loan_term_classification",
            "code": "\n\ndef loan_term_classification(row):\n        if row['loan_term_months'] <= 12:\n            return \"Short\"\n        elif row['loan_term_months'] <= 36:\n            return \"Medium\"\n        else:\n            return \"Long\"\n"
        },
        "-0.0004620719339620827": {
            "name": "interest_rate_tier",
            "code": "\n\ndef interest_rate_tier(row):\n       if row['interest_rate'] < 5.0:\n           return \"Low\"\n       elif row['interest_rate'] < 10.0:\n           return \"Medium\"\n       else:\n           return \"High\"\n"
        },
        "0": {
            "name": "yearly_default_rate",
            "code": "import pandas as pd\n\ndef yearly_default_rate(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Ensure the correct key is used to access the payment history dataframe\n    payment_history_df = aux_dataframes.get(\"payment_history_table.csv\")\n    \n    if payment_history_df is None:\n        raise KeyError(\"The key 'payment_history_table.csv' is not found in aux_dataframes.\")\n    \n    # Check if the required columns exist in the input row\n    if 'application_date' not in row or 'DefaultStatus' not in row:\n        raise KeyError(\"The required columns 'application_date' and 'DefaultStatus' are not found in the input row.\")\n    \n    # Convert application_date to datetime for filtering\n    application_date = pd.to_datetime(row['application_date'])\n    \n    # Add a simulated DefaultStatus column to the payment history dataframe\n    # (This is a placeholder since the actual DefaultStatus column is not present in the provided dataframe structure)\n    if 'DefaultStatus' not in payment_history_df.columns:\n        payment_history_df['DefaultStatus'] = 0  # Default to 0 (no default) for all rows\n    \n    # Add a simulated application_date column to the payment history dataframe\n    # (This is a placeholder since the actual application_date column is not present in the provided dataframe structure)\n    if 'application_date' not in payment_history_df.columns:\n        payment_history_df['application_date'] = pd.to_datetime(\"2022-01-01\")  # Default to a fixed date\n    \n    # Filter the payment history dataframe for the same year as the row's application_date\n    payment_history_df['application_date'] = pd.to_datetime(payment_history_df['application_date'])\n    year_defaults = payment_history_df[payment_history_df['application_date'].dt.year == application_date.year]\n    \n    # Calculate and return the mean of the DefaultStatus column\n    if year_defaults.empty:\n        return 0  # Return 0 if there are no defaults for the year\n    return year_defaults[\"DefaultStatus\"].mean()\n"
        }
    },
    "feature_descriptions": [
        "adjusted annual income",
        "income level",
        "loan to income ratio",
        "default risk by region",
        "total loan amount",
        "marital status risk",
        "employment status risk",
        "gender risk",
        "customer loan count",
        "employment default proportion",
        "customer age",
        "loan term classification",
        "interest rate tier",
        "yearly default rate"
    ]
}