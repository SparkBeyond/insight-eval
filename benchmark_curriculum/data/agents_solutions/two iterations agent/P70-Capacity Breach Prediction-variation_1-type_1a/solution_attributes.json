{
    "solved_by": "two iterations agent",
    "enriched_column_names": [
        "absence_of_historical_breach_flag",
        "peak_demand_variance",
        "region_specific_energy_demand",
        "deviation_from_avg_regional_demand",
        "seasonal_energy_demand",
        "relative_demand_to_facility_peak",
        "facility_type_breach_ratio",
        "environmental_risk_factor_average",
        "regional_environmental_risk_average",
        "max_energy_demand_difference",
        "breach_density_by_region"
    ],
    "solution_type": "SolutionType.FeatureEngineering",
    "new_feature_functions": [],
    "sorted_feature_functions": {
        "0.4506677380519297": {
            "name": "absence_of_historical_breach_flag",
            "code": "\n\ndef absence_of_historical_breach_flag(row, df_train):\n    \"\"\"Checks if the facility has any historical breach recorded.\"\"\"\n    facility_breach_history = df_train[df_train[\"facility_id\"] == row[\"facility_id\"]][\"breach_flag\"].sum()\n    return 1 if facility_breach_history == 0 else 0\n"
        },
        "0.14064262555788568": {
            "name": "peak_demand_variance",
            "code": "\n\ndef peak_demand_variance(row, df_train, aux_data: Dict[str, pd.DataFrame]):\n    # Ensure the key 'energy_demand_table.csv' exists in aux_data\n    if 'energy_demand_table.csv' not in aux_data:\n        raise KeyError(\"The key 'energy_demand_table.csv' is missing from aux_data.\")\n    \n    # Access the energy_demand_table dataframe\n    facility_demand = aux_data['energy_demand_table.csv']\n    \n    # Check if the required columns exist in the dataframe\n    required_columns = {'facility_id', 'peak_demand'}\n    if not required_columns.issubset(facility_demand.columns):\n        raise ValueError(f\"The dataframe 'energy_demand_table.csv' must contain the columns: {required_columns}\")\n    \n    # Calculate the variance of peak_demand grouped by facility_id\n    facility_demand['peak_variance'] = facility_demand.groupby('facility_id')['peak_demand'].transform('var')\n    \n    # Filter the variance for the specific facility_id in the row\n    facility_id = row['facility_id']\n    facility_variance = facility_demand.loc[facility_demand['facility_id'] == facility_id, 'peak_variance']\n    \n    # Return the first value of the variance for the facility_id, or handle missing values\n    if not facility_variance.empty:\n        return facility_variance.iloc[0]\n    else:\n        # Handle the case where the facility_id is not found in the energy_demand_table\n        raise ValueError(f\"Facility ID {facility_id} not found in 'energy_demand_table.csv'.\")\n"
        },
        "0.06148531857307073": {
            "name": "region_specific_energy_demand",
            "code": "import pandas as pd\n\ndef region_specific_energy_demand(row: pd.Series, df_train: pd.DataFrame, aux_dataframes: Dict[str, pd.DataFrame]) -> float:\n    # Ensure the required keys exist in aux_dataframes\n    if 'energy_facilities_table.csv' not in aux_dataframes or 'energy_demand_table.csv' not in aux_dataframes:\n        raise KeyError(\"Required keys 'energy_facilities_table.csv' or 'energy_demand_table.csv' are missing in aux_dataframes.\")\n    \n    # Load the required dataframes\n    facilities = aux_dataframes['energy_facilities_table.csv']\n    facility_demand = aux_dataframes['energy_demand_table.csv']\n    \n    # Check if the required columns exist in the dataframes\n    if 'facility_id' not in facilities.columns:\n        raise KeyError(\"'facility_id' column is missing in the 'energy_facilities_table.csv' dataframe.\")\n    if 'location' not in facilities.columns:\n        raise KeyError(\"'location' column is missing in the 'energy_facilities_table.csv' dataframe. This column is required to derive the 'region'.\")\n    if 'facility_id' not in facility_demand.columns:\n        raise KeyError(\"'facility_id' column is missing in the 'energy_demand_table.csv' dataframe.\")\n    if 'demand_mwh' not in facility_demand.columns:\n        raise KeyError(\"'demand_mwh' column is missing in the 'energy_demand_table.csv' dataframe.\")\n    \n    # Derive the 'region' column from the 'location' column in facilities\n    facilities = facilities.rename(columns={'location': 'region'})\n    \n    # Merge the dataframes on 'facility_id'\n    merged = pd.merge(facility_demand, facilities, on='facility_id', how='inner')\n    \n    # Group by 'region' and calculate the mean demand\n    regional_demand = merged.groupby('region')['demand_mwh'].mean()\n    \n    # Get the region for the given facility_id\n    facility_id = row['facility_id']\n    facility_region = facilities.loc[facilities['facility_id'] == facility_id, 'region']\n    \n    if facility_region.empty:\n        raise ValueError(f\"Facility ID {facility_id} not found in 'energy_facilities_table.csv'.\")\n    \n    facility_region = facility_region.iloc[0]\n    \n    # Return the regional demand for the facility's region\n    if facility_region not in regional_demand:\n        raise ValueError(f\"Region {facility_region} not found in the calculated regional demand.\")\n    \n    return regional_demand.loc[facility_region]\n"
        },
        "0.04935131768940546": {
            "name": "deviation_from_avg_regional_demand",
            "code": "import pandas as pd\n\ndef deviation_from_avg_regional_demand(row: pd.Series, aux_dataframes: Dict[str, pd.DataFrame]) -> float:\n    # Check if required keys exist in aux_dataframes\n    if 'energy_facilities_table.csv' not in aux_dataframes or 'energy_demand_table.csv' not in aux_dataframes:\n        raise KeyError(\"Required keys ('energy_facilities_table.csv', 'energy_demand_table.csv') are missing in aux_dataframes.\")\n    \n    # Load the required dataframes\n    facilities = aux_dataframes['energy_facilities_table.csv']\n    facility_demand = aux_dataframes['energy_demand_table.csv']\n    \n    # Check if the required columns exist in the dataframes\n    if 'facility_id' not in facilities.columns or 'facility_id' not in facility_demand.columns:\n        raise KeyError(\"Missing 'facility_id' column in one of the required dataframes.\")\n    if 'demand_mwh' not in facility_demand.columns:\n        raise KeyError(\"Missing 'demand_mwh' column in 'energy_demand_table.csv'.\")\n    if 'location' not in facilities.columns:\n        raise KeyError(\"Missing 'location' column in 'energy_facilities_table.csv'.\")\n    \n    # Merge the dataframes on 'facility_id'\n    merged = pd.merge(facility_demand, facilities, on='facility_id', how='inner')\n    \n    # Rename 'location' to 'region' to use it as regional information\n    if 'region' not in merged.columns:\n        merged = merged.rename(columns={'location': 'region'})\n    \n    # Check if the 'region' column exists in the merged dataframe\n    if 'region' not in merged.columns:\n        raise KeyError(\"The 'region' column is missing in the merged dataframe. Ensure the data includes regional information.\")\n    \n    # Calculate the regional average demand\n    merged['regional_avg_demand'] = merged.groupby('region')['demand_mwh'].transform('mean')\n    \n    # Get the demand for the specific facility in the input row\n    facility_id = row['facility_id']\n    facility_data = merged[merged['facility_id'] == facility_id]\n    \n    if facility_data.empty:\n        raise ValueError(f\"Facility ID {facility_id} not found in the data.\")\n    \n    # Calculate the deviation from the regional average demand\n    demand_row = facility_data.iloc[0]['demand_mwh']\n    regional_avg_demand = facility_data.iloc[0]['regional_avg_demand']\n    \n    return demand_row - regional_avg_demand\n"
        },
        "0.0414494606324788": {
            "name": "seasonal_energy_demand",
            "code": "import pandas as pd\n\ndef seasonal_energy_demand(row, df_train, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Ensure the key 'energy_demand_table.csv' exists in aux_dataframes\n    if 'energy_demand_table.csv' not in aux_dataframes:\n        raise KeyError(\"The key 'energy_demand_table.csv' is missing from aux_dataframes.\")\n    \n    # Load the energy demand table\n    facility_demand = aux_dataframes['energy_demand_table.csv']\n    \n    # Ensure the required columns exist in the dataframe\n    required_columns = {'season', 'demand_mwh'}\n    if not required_columns.issubset(facility_demand.columns):\n        raise ValueError(f\"The dataframe 'energy_demand_table.csv' must contain the columns: {required_columns}\")\n    \n    # Group by season and calculate the mean demand\n    seasonal_demand = facility_demand.groupby('season')['demand_mwh'].mean()\n    \n    # Define all possible seasons\n    all_seasons = ['winter', 'spring', 'summer', 'fall']\n    \n    # Ensure all seasons are present in the seasonal_demand Series\n    seasonal_demand = seasonal_demand.reindex(all_seasons, fill_value=0)\n    \n    # Ensure the 'date' column exists in the input row\n    if 'date' not in row:\n        raise KeyError(\"The input row must contain the 'date' key.\")\n    \n    # Convert the date to a pandas datetime object\n    try:\n        date = pd.to_datetime(row['date'])\n    except Exception as e:\n        raise ValueError(f\"Error parsing the date in the input row: {e}\")\n    \n    # Determine the season based on the date\n    month = date.month\n    if month in [12, 1, 2]:\n        season = 'winter'\n    elif month in [3, 4, 5]:\n        season = 'spring'\n    elif month in [6, 7, 8]:\n        season = 'summer'\n    elif month in [9, 10, 11]:\n        season = 'fall'\n    else:\n        raise ValueError(f\"Invalid month value derived from date: {month}\")\n    \n    # Check if the season exists in the seasonal demand data\n    if season not in seasonal_demand:\n        raise KeyError(f\"The season '{season}' is not found in the seasonal demand data.\")\n    \n    # Return the seasonal demand for the determined season\n    return seasonal_demand.loc[season]\n"
        },
        "0.03617793176303881": {
            "name": "relative_demand_to_facility_peak",
            "code": "\n\ndef relative_demand_to_facility_peak(row: pd.Series, aux_data: Dict[str, pd.DataFrame]) -> float:\n    \"\"\"Ratio of energy_output to peak_demand for the same facility.\"\"\"\n    # Check if 'energy_demand_table.csv' exists in aux_data\n    if \"energy_demand_table.csv\" not in aux_data:\n        raise KeyError(\"'energy_demand_table.csv' is missing from aux_data.\")\n    \n    # Get the energy demand table\n    facility_demand = aux_data[\"energy_demand_table.csv\"]\n    \n    # Ensure the required columns exist in the dataframe\n    required_columns = {\"facility_id\", \"peak_demand\"}\n    if not required_columns.issubset(facility_demand.columns):\n        raise KeyError(f\"The required columns {required_columns} are missing from 'energy_demand_table.csv'.\")\n    \n    # Filter the dataframe for the specific facility_id\n    facility_info = facility_demand[facility_demand[\"facility_id\"] == row[\"facility_id\"]]\n    \n    # If there is data for the facility, calculate the ratio\n    if not facility_info.empty:\n        facility_peak = facility_info[\"peak_demand\"].max()\n        # Use 'energy_output' from the row instead of 'demand_mwh'\n        return row[\"energy_output\"] / facility_peak if facility_peak > 0 else 0.0\n    else:\n        # If no data is found for the facility, return 0.0\n        return 0.0\n"
        },
        "0.03063189390084845": {
            "name": "facility_type_breach_ratio",
            "code": "\n\ndef facility_type_breach_ratio(row, df_train, aux_data: Dict[str, pd.DataFrame]):\n    \"\"\"\n    Calculate the breach ratio for the facility type of the current row, \n    ensuring no target leakage or future data leakage.\n    \n    Args:\n        row (pd.Series): The current row of the dataframe.\n        df_train (pd.DataFrame): The training dataframe.\n        aux_data (Dict[str, pd.DataFrame]): Auxiliary data containing the facilities table.\n    \n    Returns:\n        float: The breach ratio for the facility type of the current row.\n    \"\"\"\n    # Load the energy facilities table to get the facility_type\n    facilities_df = aux_data['energy_facilities_table.csv']\n    \n    # Merge df_train with facilities_df on 'facility_id' to include 'facility_type'\n    df_train = df_train.merge(facilities_df[['facility_id', 'facility_type']], on='facility_id', how='left')\n    \n    # Get the facility_type for the current row\n    facility_id = row['facility_id']\n    facility_type_row = facilities_df.loc[facilities_df['facility_id'] == facility_id, 'facility_type']\n    \n    # Check if the facility_type exists for the current row\n    if facility_type_row.empty:\n        raise KeyError(f\"Facility ID {facility_id} not found in the facilities table.\")\n    \n    facility_type = facility_type_row.iloc[0]\n    \n    # Filter df_train to exclude the current row and any rows with dates in the future\n    current_date = row['date']\n    filtered_df = df_train[(df_train['date'] < current_date) & (df_train['facility_id'] != facility_id)]\n    \n    # Calculate the breach ratios grouped by 'facility_type' using the filtered dataframe\n    breach_ratios = filtered_df.groupby('facility_type')['breach_flag'].mean()\n    \n    # Return the breach ratio for the facility_type of the current row\n    if facility_type not in breach_ratios:\n        # If the facility_type has no historical data, return a default value (e.g., 0.0 or np.nan)\n        return 0.0  # or np.nan, depending on your use case\n    \n    return breach_ratios.loc[facility_type]\n"
        },
        "0.022357432012087442": {
            "name": "environmental_risk_factor_average",
            "code": "\n\ndef environmental_risk_factor_average(row: pd.Series, aux_data: Dict[str, pd.DataFrame]) -> float:\n    # Check if 'environmental_factors_table' exists in aux_data\n    if 'environmental_factors_table.csv' not in aux_data:\n        raise KeyError(\"'environmental_factors_table.csv' is missing from aux_data.\")\n    \n    # Get the environmental factors dataframe\n    environmental_factors = aux_data['environmental_factors_table.csv']\n    \n    # Ensure the required columns exist\n    required_columns = ['temperature', 'wind_speed', 'precipitation', 'humidity']\n    for col in required_columns:\n        if col not in environmental_factors.columns:\n            raise KeyError(f\"Column '{col}' is missing from 'environmental_factors_table.csv'.\")\n    \n    # Filter rows for the given facility_id\n    facility_factors = environmental_factors[environmental_factors['facility_id'] == row['facility_id']]\n    \n    # If no rows match the facility_id, return NaN or handle appropriately\n    if facility_factors.empty:\n        return float('nan')\n    \n    # Calculate the mean of the environmental factors for the facility\n    factor_columns = required_columns  # Use the required columns for calculation\n    row_factors = facility_factors[factor_columns]\n    return row_factors.mean(axis=1).iloc[0]\n"
        },
        "0.021220129204095592": {
            "name": "regional_environmental_risk_average",
            "code": "import pandas as pd\n\ndef regional_environmental_risk_average(row: pd.Series, aux_data: Dict[str, pd.DataFrame]) -> float:\n    \"\"\"Average environmental risk factor for the entire region the facility belongs to.\"\"\"\n    # Ensure the required tables are present in aux_data\n    if \"energy_facilities_table.csv\" not in aux_data or \"environmental_factors_table.csv\" not in aux_data:\n        raise KeyError(\"Required tables are missing from aux_data: 'energy_facilities_table.csv' or 'environmental_factors_table.csv'\")\n    \n    # Load the required dataframes\n    facilities = aux_data[\"energy_facilities_table.csv\"]\n    environmental_factors = aux_data[\"environmental_factors_table.csv\"]\n    \n    # Ensure the required columns are present in the dataframes\n    required_facilities_columns = {\"facility_id\", \"facility_name\", \"location\", \"capacity_mw\", \"commission_date\", \"facility_type\"}\n    required_environmental_columns = {\"facility_id\", \"temperature\", \"wind_speed\", \"precipitation\", \"humidity\", \"env_factor_mean\"}\n    \n    if not required_facilities_columns.issubset(facilities.columns):\n        raise KeyError(f\"Missing required columns in 'energy_facilities_table.csv': {required_facilities_columns - set(facilities.columns)}\")\n    if not required_environmental_columns.issubset(environmental_factors.columns):\n        raise KeyError(f\"Missing required columns in 'environmental_factors_table.csv': {required_environmental_columns - set(environmental_factors.columns)}\")\n    \n    # Merge the facilities and environmental factors tables on 'facility_id'\n    merged = pd.merge(facilities, environmental_factors, on=\"facility_id\")\n    \n    # Use 'location' as a proxy for 'region' since 'region' is not available\n    # Identify the environmental factor columns\n    factor_columns = [\"temperature\", \"wind_speed\", \"precipitation\", \"humidity\", \"env_factor_mean\"]\n    \n    # Calculate the regional averages for the environmental factors\n    regional_averages = merged.groupby(\"location\")[factor_columns].mean()\n    \n    # Get the location (region proxy) of the current facility\n    facility_location = facilities.loc[facilities[\"facility_id\"] == row[\"facility_id\"], \"location\"]\n    if facility_location.empty:\n        raise ValueError(f\"Facility ID {row['facility_id']} not found in 'energy_facilities_table.csv'\")\n    \n    facility_location = facility_location.iloc[0]\n    \n    # Return the average of the environmental factors for the facility's location\n    if facility_location not in regional_averages.index:\n        raise ValueError(f\"Location {facility_location} not found in the merged data\")\n    \n    return regional_averages.loc[facility_location].mean()\n"
        },
        "0.009192568524053682": {
            "name": "max_energy_demand_difference",
            "code": "\n\ndef max_energy_demand_difference(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Check if 'energy_demand_table' exists in aux_dataframes\n    if 'energy_demand_table.csv' not in aux_dataframes:\n        raise KeyError(\"'energy_demand_table.csv' is missing from aux_dataframes\")\n    \n    # Get the energy demand table\n    facility_demand = aux_dataframes['energy_demand_table.csv']\n    \n    # Ensure the required columns exist in the dataframe\n    required_columns = {'facility_id', 'demand_mwh'}\n    if not required_columns.issubset(facility_demand.columns):\n        raise ValueError(f\"The dataframe 'energy_demand_table.csv' must contain the columns: {required_columns}\")\n    \n    # Group by 'facility_id' and calculate the max-min difference for 'demand_mwh'\n    max_min_diff = facility_demand.groupby('facility_id')['demand_mwh'].apply(lambda x: x.max() - x.min())\n    \n    # Get the facility_id from the row\n    facility_id = row['facility_id']\n    \n    # Check if the facility_id exists in the calculated max_min_diff\n    if facility_id not in max_min_diff:\n        raise ValueError(f\"Facility ID {facility_id} not found in the energy demand data\")\n    \n    # Return the max-min difference for the given facility_id\n    return max_min_diff.loc[facility_id]\n"
        },
        "0": {
            "name": "breach_density_by_region",
            "code": "import pandas as pd\n\ndef breach_density_by_region(row: pd.Series, df_train: pd.DataFrame, aux_data: Dict[str, pd.DataFrame]) -> float:\n    # Ensure the key 'energy_facilities_table.csv' is used to access the facilities dataframe\n    if 'energy_facilities_table.csv' not in aux_data:\n        raise KeyError(\"The key 'energy_facilities_table.csv' is missing in the aux_data dictionary.\")\n    \n    facilities = aux_data['energy_facilities_table.csv']\n    \n    # Merge df_train with facilities on 'facility_id'\n    if 'facility_id' not in df_train.columns or 'facility_id' not in facilities.columns:\n        raise KeyError(\"'facility_id' column is missing in one of the dataframes.\")\n    \n    df_train_facilities = pd.merge(df_train, facilities, on='facility_id')\n    \n    # Ensure 'location' (used as region), 'breach_flag', and 'date' columns exist\n    if 'location' not in df_train_facilities.columns or 'breach_flag' not in df_train_facilities.columns or 'date' not in df_train_facilities.columns:\n        raise KeyError(\"'location', 'breach_flag', or 'date' column is missing in the merged dataframe.\")\n    \n    # Ensure 'facility_id' and 'date' exist in the input row\n    if 'facility_id' not in row or 'date' not in row:\n        raise KeyError(\"'facility_id' or 'date' column is missing in the input row.\")\n    \n    # Ensure the facility_id exists in the facilities dataframe\n    if row['facility_id'] not in facilities['facility_id'].values:\n        raise KeyError(f\"Facility ID '{row['facility_id']}' not found in the facilities dataframe.\")\n    \n    # Get the location (region) for the current row's facility_id\n    facility_location = facilities.loc[facilities['facility_id'] == row['facility_id'], 'location'].iloc[0]\n    \n    # Filter out rows with dates in the future or the current row itself\n    current_date = pd.to_datetime(row['date'])\n    df_train_facilities['date'] = pd.to_datetime(df_train_facilities['date'])\n    filtered_df = df_train_facilities[\n        (df_train_facilities['date'] < current_date) &  # Exclude future rows\n        (df_train_facilities['facility_id'] != row['facility_id'])  # Exclude the current row\n    ]\n    \n    # Calculate breach density by location (region) using the filtered dataframe\n    if filtered_df.empty:\n        # If no data is available for the location, return a default value (e.g., 0.0 or NaN)\n        return 0.0\n    \n    breach_density = filtered_df.groupby('location')['breach_flag'].mean()\n    \n    # Ensure the location exists in the breach_density index\n    if facility_location not in breach_density.index:\n        # If the location has no historical data, return a default value (e.g., 0.0 or NaN)\n        return 0.0\n    \n    return breach_density.loc[facility_location]\n"
        }
    },
    "feature_descriptions": [
        "absence of historical breach flag",
        "peak demand variance",
        "region specific energy demand",
        "deviation from avg regional demand",
        "seasonal energy demand",
        "relative demand to facility peak",
        "facility type breach ratio",
        "environmental risk factor average",
        "regional environmental risk average",
        "max energy demand difference",
        "breach density by region"
    ]
}