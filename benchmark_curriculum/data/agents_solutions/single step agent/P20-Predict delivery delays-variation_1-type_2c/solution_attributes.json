{
    "solved_by": "single step agent",
    "enriched_column_names": [
        "delivery_speed",
        "customer_location_delay_rate",
        "inventory_to_demand_ratio",
        "item_inventory_level",
        "day_of_week",
        "customer_feedback_sentiment_score",
        "supplier_on_time_rate",
        "order_size",
        "order_month",
        "delivery_distance",
        "warehouse_delay_rate",
        "daily_item_sales",
        "warehouse_delay_proportion",
        "customer_complaint_rate",
        "customer_last_order_recency",
        "item_popularity",
        "warehouse_capacity_utilization",
        "urgent_order_ratio"
    ],
    "solution_type": "SolutionType.FeatureEngineering",
    "new_feature_functions": [],
    "sorted_feature_functions": {
        "0.40469738550721723": {
            "name": "delivery_speed",
            "code": "import pandas as pd\n\ndef delivery_speed(row: pd.Series, aux_dataframes: Dict[str, pd.DataFrame]) -> float:\n    \"\"\"\n    Calculate the delivery speed based on the difference between the scheduled delivery date\n    and the actual delivery date.\n\n    Args:\n        row (pd.Series): A row from the dataframe being processed.\n        aux_dataframes (Dict[str, pd.DataFrame]): A dictionary of auxiliary dataframes.\n\n    Returns:\n        float: The delivery speed (time difference in days). Returns 0 if dates are invalid.\n    \"\"\"\n    try:\n        # Parse the delivery_date and scheduled_delivery_date from the row\n        delivery_date = pd.to_datetime(row['delivery_date'])\n        scheduled_delivery_date = pd.to_datetime(row['scheduled_delivery_date'])\n        \n        # Calculate the delivery time difference in days\n        delivery_time = (scheduled_delivery_date - delivery_date).total_seconds() / (24 * 3600)\n        \n        return delivery_time\n    except Exception as e:\n        # If any error occurs (e.g., invalid date format), return 0\n        return 0\n"
        },
        "0.14423838594529817": {
            "name": "customer_location_delay_rate",
            "code": "\n\ndef customer_location_delay_rate(row, df_train, aux_data: Dict[str, pd.DataFrame]):\n    \"\"\"\n    Calculate the delay rate for a customer's location without introducing target leakage or using future data.\n    \n    Args:\n        row (pd.Series): The current row of the dataframe.\n        df_train (pd.DataFrame): The training dataframe containing delivery data.\n        aux_data (Dict[str, pd.DataFrame]): A dictionary containing auxiliary data, including the order details table.\n    \n    Returns:\n        float: The delay rate for the customer's location.\n    \"\"\"\n    # Extract the order_id and delivery_date from the current row\n    order_id = row['order_id']\n    delivery_date = row['delivery_date']\n    \n    # Load the order details table from aux_data\n    order_details = aux_data.get('order_details_table.csv')\n    \n    # Ensure the order_details table exists and has the required columns\n    if order_details is None or 'order_id' not in order_details.columns or 'customer_id' not in order_details.columns:\n        raise ValueError(\"The 'order_details_table.csv' is missing or does not have the required columns.\")\n    \n    # Merge df_train with order_details to get customer_id\n    df_train = df_train.merge(order_details[['order_id', 'customer_id']], on='order_id', how='left')\n    \n    # Get the customer_id for the current row\n    customer_id = order_details.loc[order_details['order_id'] == order_id, 'customer_id']\n    \n    # Ensure customer_id exists\n    if customer_id.empty:\n        return 0  # Return 0 if customer_id is not found\n    \n    customer_id = customer_id.iloc[0]  # Extract the single value\n    \n    # Filter df_train to exclude the current row and any rows with delivery dates in the future\n    filtered_df = df_train[\n        (df_train['customer_id'] == customer_id) &  # Only consider rows for the same customer\n        (df_train['delivery_date'] < delivery_date)  # Exclude rows with delivery dates in the future\n    ]\n    \n    # Calculate the delay rate for the customer_id\n    if filtered_df.empty:\n        return 0  # Return 0 if there are no past deliveries for the customer\n    \n    delay_rate = filtered_df['delay_flag'].mean()\n    \n    # Return the calculated delay rate\n    return delay_rate\n"
        },
        "0.04600813421009475": {
            "name": "inventory_to_demand_ratio",
            "code": "\n\ndef inventory_to_demand_ratio(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    inventory_level = item_inventory_level(row, aux_dataframes)\n    daily_sales = daily_item_sales(row, aux_dataframes)\n    if daily_sales > 0:\n        return inventory_level / daily_sales\n    return 0\n\ndef daily_item_sales(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Extract the product_id (item_id) from the auxiliary order_details_table\n    order_id = row['order_id']\n    order_table = aux_dataframes['order_details_table.csv']\n    \n    # Find the product_id for the given order_id\n    order_details = order_table[order_table['order_id'] == order_id]\n    if order_details.empty:\n        return 0  # If no matching order is found, return 0\n    \n    product_id = order_details['product_id'].iloc[0]\n    \n    # Calculate daily sales for the given product_id\n    item_orders = order_table[order_table['product_id'] == product_id]\n    if not item_orders.empty:\n        total_sales = item_orders['quantity'].sum()\n        duration_days = (item_orders['order_date'].max() - item_orders['order_date'].min()).days\n        return total_sales / max(duration_days, 1)\n    return 0\n\ndef item_inventory_level(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Extract the warehouse_id and product_id (item_id) from the auxiliary order_details_table\n    order_id = row['order_id']\n    order_table = aux_dataframes['order_details_table.csv']\n    inventory_data = aux_dataframes['warehouse_inventory_table.csv']\n    \n    # Find the warehouse_id and product_id for the given order_id\n    order_details = order_table[order_table['order_id'] == order_id]\n    if order_details.empty:\n        return 0  # If no matching order is found, return 0\n    \n    warehouse_id = order_details['warehouse_id'].iloc[0]\n    product_id = order_details['product_id'].iloc[0]\n    \n    # Find the inventory level for the given warehouse_id and product_id\n    current_item = inventory_data[\n        (inventory_data['warehouse_id'] == warehouse_id) &\n        (inventory_data['product_id'] == product_id)\n    ]\n    if not current_item.empty:\n        return current_item['current_stock'].iloc[0]\n    return 0\n"
        },
        "0.04464192272876009": {
            "name": "item_inventory_level",
            "code": "\n\ndef item_inventory_level(row: pd.Series, aux_data: Dict[str, pd.DataFrame]) -> int:\n    # Extract the order_id from the row\n    order_id = row['order_id']\n    \n    # Get the order details dataframe\n    order_details = aux_data['order_details_table.csv']\n    \n    # Find the corresponding order details for the given order_id\n    order_row = order_details[order_details['order_id'] == order_id]\n    \n    # If no matching order is found, return 0\n    if order_row.empty:\n        return 0\n    \n    # Extract the warehouse_id and product_id (which corresponds to item_id)\n    warehouse_id = order_row['warehouse_id'].iloc[0]\n    item_id = order_row['product_id'].iloc[0]\n    \n    # Get the warehouse inventory dataframe\n    inventory_data = aux_data['warehouse_inventory_table.csv']\n    \n    # Find the inventory data for the given warehouse_id and item_id\n    current_item = inventory_data[\n        (inventory_data['warehouse_id'] == warehouse_id) &\n        (inventory_data['product_id'] == item_id)\n    ]\n    \n    # If the item exists in the inventory, return its current stock\n    if not current_item.empty:\n        return current_item['current_stock'].iloc[0]\n    \n    # If the item is not found in the inventory, return 0\n    return 0\n"
        },
        "0.02802911443246655": {
            "name": "day_of_week",
            "code": "import pandas as pd\n\ndef day_of_week(row, aux_data: Dict[str, pd.DataFrame]):\n    # Ensure 'delivery_date' is a datetime object\n    delivery_date = pd.to_datetime(row['delivery_date'])\n    # Return the day of the week (0=Monday, 6=Sunday)\n    return delivery_date.weekday()\n"
        },
        "0.027484204967438405": {
            "name": "customer_feedback_sentiment_score",
            "code": "\n\ndef customer_feedback_sentiment_score(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Extract the relevant dataframes\n    feedback_data = aux_dataframes['customer_feedback_table.csv']\n    order_details_data = aux_dataframes['order_details_table.csv']\n    \n    # Get the order_id from the current row\n    order_id = row['order_id']\n    \n    # Find the customer_id corresponding to the order_id\n    customer_row = order_details_data[order_details_data['order_id'] == order_id]\n    if customer_row.empty:\n        return 0  # If no matching order_id is found, return 0\n    \n    customer_id = customer_row.iloc[0]['customer_id']\n    \n    # Filter feedback data for the specific customer_id\n    feedback = feedback_data[feedback_data['customer_id'] == customer_id]\n    if not feedback.empty:\n        # Use the 'rating' column as the sentiment score\n        return feedback['rating'].mean()  # Calculate the mean rating\n    \n    return 0  # Return 0 if no feedback is found\n"
        },
        "0.025094928439152016": {
            "name": "supplier_on_time_rate",
            "code": "\n\ndef supplier_on_time_rate(row, df_train, aux_dataframes):\n    \"\"\"\n    Calculate supplier's on-time delivery rate using the supplier_info_table.\n    \n    Args:\n        row (pd.Series): A single row of the dataset.\n        df_train (pd.DataFrame): Entire train dataset (unused in this feature).\n        aux_dataframes (dict): Dictionary of auxiliary dataframes.\n    \n    Returns:\n        float: On-time delivery rate for the supplier.\n    \"\"\"\n    # Extract the order_id from the row\n    order_id = row['order_id']\n    \n    # Load the order details table to find the supplier_id\n    order_details = aux_dataframes['order_details_table.csv']\n    \n    # Check if the order_id exists in the order_details table\n    if order_id not in order_details['order_id'].values:\n        # If no matching order_id is found, return 0\n        return 0\n    \n    # Load the supplier info table\n    supplier_data = aux_dataframes['supplier_info_table.csv']\n    \n    # Merge order_details with supplier_data to associate orders with suppliers\n    # Assuming there is a relationship between order_details and supplier_info_table\n    # (e.g., via a warehouse_id or product_id that maps to a supplier_id)\n    merged_data = order_details.merge(\n        supplier_data,\n        how='left',\n        left_on='warehouse_id',  # Assuming warehouse_id maps to supplier_id\n        right_on='supplier_id'\n    )\n    \n    # Filter the merged data for the given order_id\n    supplier_row = merged_data[merged_data['order_id'] == order_id]\n    \n    if supplier_row.empty:\n        # If no supplier is found for the order, return 0\n        return 0\n    \n    # Extract the supplier_id\n    supplier_id = supplier_row.iloc[0]['supplier_id']\n    \n    # Filter the supplier data for the given supplier_id\n    supplier_deliveries = supplier_data[supplier_data['supplier_id'] == supplier_id]\n    \n    if len(supplier_deliveries) > 0:\n        # Calculate the on-time delivery rate\n        on_time_rate = supplier_deliveries['on_time_supply_rate'].iloc[0]  # Use the precomputed on_time_supply_rate\n        return on_time_rate\n    \n    # If no deliveries are found for the supplier, return 0\n    return 0\n"
        },
        "0.024778422344797695": {
            "name": "order_size",
            "code": "\n\ndef order_size(row: pd.Series, aux_data: Dict[str, pd.DataFrame]) -> float:\n    # Extract the order_id from the row\n    order_id = row['order_id']\n    \n    # Get the order_details_table from aux_data\n    order_details_table = aux_data.get('order_details_table.csv')\n    \n    if order_details_table is None:\n        raise ValueError(\"order_details_table.csv is missing from aux_data\")\n    \n    # Find the row in order_details_table corresponding to the order_id\n    order_details = order_details_table[order_details_table['order_id'] == order_id]\n    \n    if order_details.empty:\n        raise ValueError(f\"No order details found for order_id: {order_id}\")\n    \n    # Extract the quantity (order_quantity) from the order details\n    order_quantity = order_details.iloc[0]['quantity']\n    \n    # Assume a default item_volume if not provided (e.g., 1.0)\n    # You can modify this logic based on your specific requirements\n    item_volume = 1.0  # Default value for item_volume\n    \n    # Calculate and return the order size\n    return order_quantity * item_volume\n"
        },
        "0.024699925062248638": {
            "name": "order_month",
            "code": "import pandas as pd\n\ndef order_month(row, aux_data: Dict[str, pd.DataFrame]):\n    # Extract the order_id from the row\n    order_id = row['order_id']\n    \n    # Look up the order_details_table.csv dataframe in aux_data\n    order_details_df = aux_data['order_details_table.csv']\n    \n    # Find the row in order_details_df that matches the order_id\n    order_row = order_details_df[order_details_df['order_id'] == order_id]\n    \n    # If the order_id exists, extract the month from the order_date\n    if not order_row.empty:\n        order_date = pd.to_datetime(order_row.iloc[0]['order_date'])\n        return order_date.month\n    \n    # If the order_id does not exist, return None\n    return None\n"
        },
        "0.008155944966653393": {
            "name": "delivery_distance",
            "code": "\n\ndef delivery_distance(row, aux_data: Dict[str, pd.DataFrame]):\n    # Extract the delivery distance directly from the row\n    if 'distance_km' in row:\n        return row['distance_km']\n    return 0\n"
        },
        "0.00804197435443675": {
            "name": "warehouse_delay_rate",
            "code": "\n\ndef warehouse_delay_rate(row, df_train, aux_data: Dict[str, pd.DataFrame]):\n    # Extract the order_id from the row\n    order_id = row['order_id']\n    \n    # Get the order_details_table and customer_feedback_table from aux_data\n    order_table = aux_data['order_details_table.csv']\n    feedback_table = aux_data['customer_feedback_table.csv']\n    \n    # Find the warehouse_id corresponding to the order_id\n    order_row = order_table[order_table['order_id'] == order_id]\n    if order_row.empty:\n        # If no matching order_id is found, return 0\n        return 0\n    \n    warehouse_id = order_row.iloc[0]['warehouse_id']\n    \n    # Filter the feedback_table for orders associated with the given warehouse_id\n    # Join the order_table with the feedback_table to get the warehouse_id for each order\n    merged_table = order_table.merge(feedback_table, on='order_id', how='inner')\n    warehouse_data = merged_table[merged_table['warehouse_id'] == warehouse_id]\n    \n    # Check if there is any data for the warehouse\n    if len(warehouse_data) > 0:\n        # Calculate the delay rate using the 'was_delayed' column\n        delay_rate = warehouse_data['was_delayed'].mean()\n        return delay_rate\n    \n    # If no data is found for the warehouse, return 0\n    return 0\n"
        },
        "0.00696028930918137": {
            "name": "daily_item_sales",
            "code": "import pandas as pd\n\ndef daily_item_sales(row: pd.Series, aux_dataframes: Dict[str, pd.DataFrame]) -> float:\n    # Extract the product_id from the row\n    product_id = row['order_id']  # Assuming 'order_id' is the correct column to match with 'product_id'\n    \n    # Get the order details table from aux_dataframes\n    order_table = aux_dataframes['order_details_table.csv']\n    \n    # Ensure the 'order_date' column is in datetime format\n    if order_table['order_date'].dtype == 'object':  # Check if the column is of type string\n        order_table['order_date'] = pd.to_datetime(order_table['order_date'])\n    \n    # Filter the order table for rows matching the product_id\n    item_orders = order_table[order_table['product_id'] == product_id]\n    \n    # If there are matching orders, calculate the daily sales\n    if not item_orders.empty:\n        total_sales = item_orders['quantity'].sum()  # Use 'quantity' instead of 'order_quantity'\n        duration_days = (item_orders['order_date'].max() - item_orders['order_date'].min()).days\n        return total_sales / max(duration_days, 1)  # Avoid division by zero\n    \n    # If no matching orders, return 0\n    return 0\n"
        },
        "0.005033749551579411": {
            "name": "warehouse_delay_proportion",
            "code": "import pandas as pd\n\ndef warehouse_delay_proportion(row: pd.Series, df_train: pd.DataFrame, aux_data: Dict[str, pd.DataFrame]) -> float:\n    \"\"\"\n    Calculates the proportion of delayed orders for a specific warehouse.\n    \n    Args:\n        row (pd.Series): A single row of the dataset.\n        df_train (pd.DataFrame): Entire train dataset.\n        aux_data (Dict[str, pd.DataFrame]): Dictionary of auxiliary dataframes.\n    \n    Returns:\n        float: Proportion of delayed orders for the warehouse.\n    \"\"\"\n    # Extract the order_id from the row\n    order_id = row['order_id']\n    \n    # Load the order details and customer feedback tables from aux_data\n    order_table = aux_data['order_details_table.csv']\n    feedback_table = aux_data['customer_feedback_table.csv']\n    \n    # Find the warehouse_id corresponding to the order_id\n    warehouse_row = order_table[order_table['order_id'] == order_id]\n    \n    # If the order_id is not found in the order_table, return 0\n    if warehouse_row.empty:\n        return 0.0\n    \n    # Extract the warehouse_id\n    warehouse_id = warehouse_row.iloc[0]['warehouse_id']\n    \n    # Merge order_table with feedback_table on 'order_id' to get delay information\n    merged_table = pd.merge(order_table, feedback_table[['order_id', 'was_delayed']], on='order_id', how='left')\n    \n    # Filter orders for the specific warehouse\n    warehouse_orders = merged_table[merged_table['warehouse_id'] == warehouse_id]\n    \n    # Check if there are any orders for the warehouse\n    if len(warehouse_orders) > 0:\n        # Calculate the proportion of delayed orders\n        delay_proportion = warehouse_orders['was_delayed'].mean()\n        return delay_proportion\n    \n    # If no orders are found for the warehouse, return 0\n    return 0.0\n"
        },
        "0.004456983947597995": {
            "name": "customer_complaint_rate",
            "code": "\n\ndef customer_complaint_rate(row, aux_data: Dict[str, pd.DataFrame]):\n    # Get the auxiliary dataframes\n    feedback_data = aux_data['customer_feedback_table.csv']\n    order_details = aux_data['order_details_table.csv']\n    \n    # Retrieve the customer_id using the order_id from the row\n    order_id = row['order_id']\n    customer_row = order_details[order_details['order_id'] == order_id]\n    \n    if customer_row.empty:\n        # If no matching order_id is found, return 0\n        return 0\n    \n    customer_id = customer_row.iloc[0]['customer_id']\n    \n    # Filter the feedback data for the given customer_id\n    customer_feedback = feedback_data[feedback_data['customer_id'] == customer_id]\n    \n    if len(customer_feedback) > 0:\n        # Calculate and return the mean of the 'is_complaint' column\n        return customer_feedback['was_delayed'].mean()\n    \n    # If no feedback is found for the customer, return 0\n    return 0\n"
        },
        "0.001444621442293691": {
            "name": "customer_last_order_recency",
            "code": "import pandas as pd\n\ndef customer_last_order_recency(row, aux_data: Dict[str, pd.DataFrame]):\n    # Extract the order_id from the row\n    order_id = row['order_id']\n    \n    # Get the order_details_table from the auxiliary data\n    order_table = aux_data['order_details_table.csv']\n    \n    # Find the customer_id associated with the given order_id\n    if order_id in order_table['order_id'].values:\n        customer_id = order_table.loc[order_table['order_id'] == order_id, 'customer_id'].iloc[0]\n    else:\n        # If the order_id is not found, return -1\n        return -1\n    \n    # Filter the orders for the specific customer_id\n    customer_orders = order_table[order_table['customer_id'] == customer_id]\n    \n    # Check if the customer has any orders\n    if len(customer_orders) > 0:\n        # Get the most recent order date\n        last_order_date = customer_orders['order_date'].max()\n        # Calculate the recency in days\n        return (pd.Timestamp.now() - pd.Timestamp(last_order_date)).days\n    \n    # If the customer has no orders, return -1\n    return -1\n"
        },
        "0.0006132917428344687": {
            "name": "item_popularity",
            "code": "\n\ndef item_popularity(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Extract the order_id from the row\n    order_id = row['order_id']\n    \n    # Access the order_details_table.csv dataframe\n    order_table = aux_dataframes['order_details_table.csv']\n    \n    # Find the product_id(s) associated with the given order_id\n    product_ids = order_table[order_table['order_id'] == order_id]['product_id']\n    \n    # If no product_id is found, return 0\n    if product_ids.empty:\n        return 0\n    \n    # Count the number of rows in the order_table where product_id matches\n    product_id = product_ids.iloc[0]  # Assuming one product_id per order_id\n    return order_table[order_table['product_id'] == product_id].shape[0]\n"
        },
        "0.0005473418219015508": {
            "name": "warehouse_capacity_utilization",
            "code": "\n\ndef warehouse_capacity_utilization(row, aux_data: Dict[str, pd.DataFrame]):\n    # Extract the order_id from the row\n    order_id = row['order_id']\n    \n    # Get the order details dataframe\n    order_details = aux_data['order_details_table.csv']\n    \n    # Find the warehouse_id corresponding to the order_id\n    order_info = order_details[order_details['order_id'] == order_id]\n    if len(order_info) == 0:\n        # If no matching order_id is found, return 0\n        return 0\n    \n    # Extract the warehouse_id\n    warehouse_id = order_info['warehouse_id'].iloc[0]\n    \n    # Get the warehouse inventory dataframe\n    inventory_data = aux_data['warehouse_inventory_table.csv']\n    \n    # Filter the inventory data for the specific warehouse_id\n    warehouse_info = inventory_data[inventory_data['warehouse_id'] == warehouse_id]\n    if len(warehouse_info) > 0:\n        # Calculate the current stock and max capacity\n        current_stock = warehouse_info['current_stock'].sum()\n        max_capacity = warehouse_info['current_stock'].sum() + warehouse_info['reorder_level'].sum()\n        # Return the capacity utilization\n        return current_stock / max_capacity if max_capacity > 0 else 0\n    \n    # If no warehouse information is found, return 0\n    return 0\n"
        },
        "0": {
            "name": "urgent_order_ratio",
            "code": "\n\ndef urgent_order_ratio(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Get the order details table\n    order_table = aux_dataframes['order_details_table.csv']\n    \n    # Find the order_id for the given row\n    order_id = row['order_id']\n    customer_id_row = order_table[order_table['order_id'] == order_id]\n    \n    # If the order_id is not found, return 0\n    if customer_id_row.empty:\n        return 0\n    \n    # Extract the customer_id\n    customer_id = customer_id_row.iloc[0]['customer_id']\n    \n    # Get all orders for the customer\n    customer_orders = order_table[order_table['customer_id'] == customer_id]\n    \n    # Check if the 'order_status' column exists in the order table\n    if 'order_status' not in customer_orders.columns:\n        raise KeyError(\"'order_status' column is missing in the order_details_table.csv dataframe.\")\n    \n    # Define urgency based on the 'order_status' column\n    customer_orders['is_urgent'] = customer_orders['order_status'].apply(lambda x: 1 if x == 'Urgent' else 0)\n    \n    # Calculate the urgent order ratio\n    if len(customer_orders) > 0:\n        return customer_orders['is_urgent'].sum() / len(customer_orders)\n    \n    # If no orders are found, return 0\n    return 0\n"
        }
    },
    "feature_descriptions": [
        "delivery speed",
        "customer location delay rate",
        "inventory to demand ratio",
        "item inventory level",
        "day of week",
        "customer feedback sentiment score",
        "supplier on time rate",
        "order size",
        "order month",
        "delivery distance",
        "warehouse delay rate",
        "daily item sales",
        "warehouse delay proportion",
        "customer complaint rate",
        "customer last order recency",
        "item popularity",
        "warehouse capacity utilization",
        "urgent order ratio"
    ]
}