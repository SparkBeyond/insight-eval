{
    "solved_by": "single step agent",
    "enriched_column_names": [
        "failures_in_recent_past",
        "time_since_last_maintenance",
        "equipment_failure_rate",
        "equipment_age",
        "repair_time_for_maintenance",
        "operational_hours_to_downtime_ratio",
        "manufacturer_failure_rate"
    ],
    "solution_type": "SolutionType.FeatureEngineering",
    "new_feature_functions": [],
    "sorted_feature_functions": {
        "0.07388324014926258": {
            "name": "failures_in_recent_past",
            "code": "import pandas as pd\n\ndef failures_in_recent_past(row, df_train: pd.DataFrame):\n    # Ensure the 'timestamp' column is in datetime format\n    df_train['timestamp'] = pd.to_datetime(df_train['timestamp'])\n    row_timestamp = pd.to_datetime(row['timestamp'])\n    \n    # Filter equipment failures for the same equipment_id\n    equipment_failures = df_train[df_train['equipment_id'] == row['equipment_id']]\n    \n    # Exclude the current row to prevent target leakage\n    equipment_failures = equipment_failures[equipment_failures['timestamp'] != row_timestamp]\n    \n    # Filter failures within the last 30 days and ensure no future data is used\n    recent_failures = equipment_failures[\n        (equipment_failures['timestamp'] < row_timestamp) & \n        (equipment_failures['timestamp'] >= (row_timestamp - pd.Timedelta(days=30)))\n    ]\n    \n    # Return the sum of 'failure_event' in the recent failures\n    return recent_failures['failure_event'].sum()\n"
        },
        "0.05643894809632451": {
            "name": "time_since_last_maintenance",
            "code": "import pandas as pd\n\ndef time_since_last_maintenance(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Ensure the key matches the provided aux_data dictionary\n    if 'maintenance_logs_table.csv' not in aux_dataframes:\n        raise KeyError(\"The key 'maintenance_logs_table.csv' is missing in aux_dataframes.\")\n    \n    # Access the maintenance logs table\n    maintenance_logs = aux_dataframes['maintenance_logs_table.csv']\n    \n    # Filter the maintenance logs for the specific equipment_id\n    history = maintenance_logs[maintenance_logs['equipment_id'] == row['equipment_id']]\n    \n    # If no maintenance history exists, return None\n    if history.empty:\n        return None\n    \n    # Convert the 'maintenance_date' column to datetime and find the most recent date\n    last_maintenance_date = pd.to_datetime(history['maintenance_date']).max()\n    \n    # Calculate the difference in days between the current date and the last maintenance date\n    current_date = pd.to_datetime(row['timestamp'])  # Use 'timestamp' from the row\n    return (current_date - last_maintenance_date).days\n"
        },
        "0.05134844598027535": {
            "name": "equipment_failure_rate",
            "code": "\n\ndef equipment_failure_rate(row, df_train: pd.DataFrame):\n    # Filter the training data to include only rows with the same equipment_id\n    # and timestamps strictly earlier than the current row's timestamp\n    history = df_train[\n        (df_train['equipment_id'] == row['equipment_id']) &\n        (df_train['timestamp'] < row['timestamp'])\n    ]\n    \n    # If there is no historical data, return 0\n    if len(history) == 0:\n        return 0\n    \n    # Calculate and return the mean failure_event from the historical data\n    return history['failure_event'].mean()\n"
        },
        "0.030493353302445025": {
            "name": "equipment_age",
            "code": "import pandas as pd\n\ndef equipment_age(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Ensure the key matches the expected filename or dictionary key\n    equipment_specs_key = 'equipment_specs_table.csv'\n    \n    # Check if the key exists in aux_dataframes\n    if equipment_specs_key not in aux_dataframes:\n        raise KeyError(f\"'{equipment_specs_key}' not found in aux_dataframes\")\n    \n    # Access the equipment_specs_table dataframe\n    equipment_specs_table = aux_dataframes[equipment_specs_key]\n    \n    # Ensure the required columns exist in the dataframe\n    required_columns = {'equipment_id', 'installation_date'}\n    if not required_columns.issubset(equipment_specs_table.columns):\n        raise ValueError(f\"Missing required columns in '{equipment_specs_key}'. Expected columns: {required_columns}\")\n    \n    # Retrieve the installation date for the given equipment_id\n    try:\n        install_date = equipment_specs_table.set_index('equipment_id').at[row['equipment_id'], 'installation_date']\n    except KeyError:\n        raise KeyError(f\"Equipment ID '{row['equipment_id']}' not found in '{equipment_specs_key}'\")\n    \n    # Calculate the age in days\n    return (pd.to_datetime(row['timestamp']) - pd.to_datetime(install_date)).days\n"
        },
        "0.014390185980165908": {
            "name": "repair_time_for_maintenance",
            "code": "\n\ndef repair_time_for_maintenance(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Check if 'maintenance_logs_table' exists in aux_dataframes\n    if 'maintenance_logs_table.csv' not in aux_dataframes:\n        raise KeyError(\"'maintenance_logs_table.csv' not found in aux_dataframes\")\n    \n    # Get the maintenance logs dataframe\n    maintenance_logs = aux_dataframes['maintenance_logs_table.csv']\n    \n    # Filter the maintenance logs for the relevant equipment_id\n    relevant_maintenance = maintenance_logs[maintenance_logs['equipment_id'] == row['equipment_id']]\n    \n    # If no relevant maintenance logs are found, return None\n    if relevant_maintenance.empty:\n        return None\n    \n    # Calculate and return the mean downtime_duration\n    return relevant_maintenance['downtime_duration'].mean()\n"
        },
        "0.011709651154247038": {
            "name": "operational_hours_to_downtime_ratio",
            "code": "\n\ndef operational_hours_to_downtime_ratio(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Check if the required table is present in aux_dataframes\n    if 'maintenance_logs_table.csv' not in aux_dataframes:\n        raise KeyError(\"The required table 'maintenance_logs_table.csv' is missing from aux_dataframes.\")\n    \n    # Extract the maintenance logs table\n    maintenance_logs = aux_dataframes['maintenance_logs_table.csv']\n    \n    # Ensure the required columns exist in the maintenance logs table\n    required_columns = {'equipment_id', 'downtime_duration'}\n    if not required_columns.issubset(maintenance_logs.columns):\n        raise ValueError(f\"The 'maintenance_logs_table.csv' is missing one or more required columns: {required_columns}\")\n    \n    # Filter maintenance logs for the specific equipment_id\n    equipment_id = row['equipment_id']\n    equipment_logs = maintenance_logs[maintenance_logs['equipment_id'] == equipment_id]\n    \n    # Calculate total downtime for the equipment\n    total_downtime = equipment_logs['downtime_duration'].sum()\n    \n    # Estimate operational time (assuming total time is the sum of downtime and operational time)\n    # Here, we assume a placeholder value for total operational time if not explicitly provided\n    total_operational_time = 1000  # Placeholder value, replace with actual logic if available\n    \n    # Calculate the ratio\n    return total_operational_time / (total_downtime if total_downtime > 0 else 1)\n"
        },
        "0": {
            "name": "manufacturer_failure_rate",
            "code": "import pandas as pd\n\ndef manufacturer_failure_rate(row, aux_dataframes: Dict[str, pd.DataFrame], full_data: pd.DataFrame):\n    \"\"\"\n    Calculate the failure rate for the manufacturer of the given equipment, \n    ensuring no target leakage or future data leakage.\n\n    Args:\n        row (pd.Series): A single row of the input dataframe.\n        aux_dataframes (Dict[str, pd.DataFrame]): A dictionary containing auxiliary dataframes.\n        full_data (pd.DataFrame): The full dataset to calculate failure rates from.\n\n    Returns:\n        float: The failure rate for the manufacturer.\n    \"\"\"\n    # Ensure the key exists in the aux_dataframes dictionary\n    if 'equipment_specs_table.csv' not in aux_dataframes:\n        raise KeyError(\"'equipment_specs_table.csv' not found in aux_dataframes\")\n    \n    # Get the equipment_specs_table dataframe\n    specs = aux_dataframes['equipment_specs_table.csv']\n    \n    # Ensure the required columns exist in the specs dataframe\n    required_columns = {'equipment_id', 'manufacturer'}\n    if not required_columns.issubset(specs.columns):\n        raise KeyError(f\"Missing required columns in 'equipment_specs_table.csv': {required_columns - set(specs.columns)}\")\n    \n    # Ensure the input dataframe has the required columns\n    if 'failure_event' not in row or 'equipment_id' not in row or 'timestamp' not in row:\n        raise KeyError(\"Input row must contain 'failure_event', 'equipment_id', and 'timestamp' columns\")\n    \n    # Merge the input row with the equipment_specs_table to get the manufacturer\n    equipment_id = row['equipment_id']\n    manufacturer_row = specs[specs['equipment_id'] == equipment_id]\n    \n    if manufacturer_row.empty:\n        raise ValueError(f\"Equipment ID '{equipment_id}' not found in 'equipment_specs_table.csv'\")\n    \n    manufacturer = manufacturer_row['manufacturer'].values[0]\n    \n    # Filter the full_data to exclude the current row and any data from the future\n    current_timestamp = row['timestamp']\n    filtered_data = full_data[\n        (full_data['timestamp'] < current_timestamp) &  # Exclude future data\n        (full_data['equipment_id'] != equipment_id)    # Exclude the current row\n    ]\n    \n    # Merge the filtered data with the specs table to get manufacturer information\n    filtered_data = pd.merge(\n        filtered_data,\n        specs[['equipment_id', 'manufacturer']],\n        on='equipment_id',\n        how='left'\n    )\n    \n    # Filter the data for the current manufacturer\n    manufacturer_data = filtered_data[filtered_data['manufacturer'] == manufacturer]\n    \n    if manufacturer_data.empty:\n        # If no data is available for the manufacturer, return a default failure rate (e.g., 0.0)\n        return 0.0\n    \n    # Calculate the failure rate for the manufacturer\n    failure_rate = manufacturer_data['failure_event'].mean()\n    \n    return failure_rate\n"
        }
    },
    "feature_descriptions": [
        "failures in recent past",
        "time since last maintenance",
        "equipment failure rate",
        "equipment age",
        "repair time for maintenance",
        "operational hours to downtime ratio",
        "manufacturer failure rate"
    ]
}