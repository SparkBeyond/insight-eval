{
    "solved_by": "single step agent",
    "enriched_column_names": [
        "days_since_last_marketing_response",
        "avg_transaction_amount_last_3_months",
        "avg_transaction_amount",
        "transaction_frequency_last_year",
        "payment_to_transaction_balance",
        "transaction_variety",
        "account_utilization",
        "late_payment_frequency"
    ],
    "solution_type": "SolutionType.FeatureEngineering",
    "new_feature_functions": [],
    "sorted_feature_functions": {
        "0.1482926656991462": {
            "name": "days_since_last_marketing_response",
            "code": "import datetime\nimport pandas as pd\n\ndef calculate_days(date_1, date_2):\n    # Ensure date_1 and date_2 are datetime objects\n    if pd.isnull(date_1):\n        return None\n    days = (date_2 - date_1).days\n    return max(days, 0) if days is not None else None\n\ndef days_since_last_marketing_response(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Check if the key 'marketing_campaign_responses_table' exists in aux_dataframes\n    if \"marketing_campaign_responses_table.csv\" not in aux_dataframes:\n        raise KeyError(\"The key 'marketing_campaign_responses_table.csv' is missing in aux_dataframes.\")\n    \n    # Get the marketing campaign responses table\n    marketing = aux_dataframes[\"marketing_campaign_responses_table.csv\"]\n    \n    # Ensure the required columns exist in the marketing dataframe\n    required_columns = {'customer_id', 'response_date'}\n    if not required_columns.issubset(marketing.columns):\n        raise ValueError(f\"The marketing_campaign_responses_table.csv is missing required columns: {required_columns - set(marketing.columns)}\")\n    \n    # Filter the marketing dataframe for the given customer_id\n    filtered = marketing[marketing['customer_id'] == row['customer_id']]\n    if filtered.empty:\n        return None\n    \n    # Convert response_date to datetime and find the most recent response date\n    filtered['response_date'] = pd.to_datetime(filtered['response_date'], errors='coerce')\n    last_response_date = filtered['response_date'].max()\n    \n    # Calculate the number of days since the last response\n    return calculate_days(last_response_date, datetime.datetime.now())\n"
        },
        "0.1022959235133832": {
            "name": "avg_transaction_amount_last_3_months",
            "code": "import pandas as pd\n\ndef avg_transaction_amount_last_3_months(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Ensure the key exists in the aux_dataframes dictionary\n    if \"transaction_history_table.csv\" not in aux_dataframes:\n        raise KeyError(\"The key 'transaction_history_table.csv' is missing from aux_dataframes.\")\n    \n    # Get the transaction history table\n    transactions = aux_dataframes[\"transaction_history_table.csv\"]\n    \n    # Ensure the required columns exist in the DataFrame\n    required_columns = {'account_id', 'transaction_date', 'transaction_amount'}\n    if not required_columns.issubset(transactions.columns):\n        raise KeyError(f\"The transaction history table is missing one or more required columns: {required_columns}\")\n    \n    # Calculate the date three months ago\n    three_months_ago = pd.Timestamp.now() - pd.DateOffset(months=3)\n    \n    # Filter transactions for the given account_id and within the last 3 months\n    filtered = transactions[\n        (transactions['account_id'] == row['account_id']) & \n        (pd.to_datetime(transactions['transaction_date']) >= three_months_ago)\n    ]\n    \n    # If no transactions are found, return 0\n    if filtered.empty:\n        return 0\n    \n    # Calculate and return the average transaction amount\n    return filtered['transaction_amount'].mean()\n"
        },
        "0.07932745424785653": {
            "name": "avg_transaction_amount",
            "code": "\n\ndef avg_transaction_amount(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Ensure the key 'transaction_history_table' exists in aux_dataframes\n    if \"transaction_history_table.csv\" not in aux_dataframes:\n        raise KeyError(\"The key 'transaction_history_table.csv' is missing from aux_dataframes.\")\n    \n    # Get the transaction history table\n    transactions = aux_dataframes[\"transaction_history_table.csv\"]\n    \n    # Filter transactions by account_id (not customer_id, as per the provided column names)\n    filtered = transactions[transactions['account_id'] == row['account_id']]\n    \n    # If no transactions are found, return 0\n    if filtered.empty:\n        return 0\n    \n    # Calculate and return the average transaction amount\n    return filtered['transaction_amount'].mean()\n"
        },
        "0.04766579953996318": {
            "name": "transaction_frequency_last_year",
            "code": "import datetime\nimport pandas as pd\n\ndef transaction_frequency_last_year(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Ensure the key exists in the aux_dataframes dictionary\n    if \"transaction_history_table.csv\" not in aux_dataframes:\n        raise KeyError(\"The key 'transaction_history_table.csv' is missing from aux_dataframes.\")\n    \n    # Retrieve the transaction history table\n    transactions = aux_dataframes[\"transaction_history_table.csv\"]\n    \n    # Ensure the required columns exist in the dataframe\n    required_columns = {'account_id', 'transaction_date'}\n    if not required_columns.issubset(transactions.columns):\n        raise ValueError(f\"The transaction history table is missing one or more required columns: {required_columns}\")\n    \n    # Calculate the date one year ago\n    one_year_ago = datetime.datetime.now() - pd.DateOffset(years=1)\n    \n    # Filter transactions for the given account_id and within the last year\n    filtered = transactions[\n        (transactions['account_id'] == row['account_id']) & \n        (pd.to_datetime(transactions['transaction_date']) >= one_year_ago)\n    ]\n    \n    # Return the count of filtered transactions\n    return len(filtered)\n"
        },
        "0.04042556315952214": {
            "name": "payment_to_transaction_balance",
            "code": "\n\ndef payment_to_transaction_balance(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Ensure the required keys exist in aux_dataframes\n    if \"transaction_history_table.csv\" not in aux_dataframes or \"payment_history_table.csv\" not in aux_dataframes:\n        raise KeyError(\"Required tables are missing from aux_dataframes: 'transaction_history_table.csv' or 'payment_history_table.csv'\")\n    \n    # Load the transaction and payment history tables\n    transactions = aux_dataframes[\"transaction_history_table.csv\"]\n    payments = aux_dataframes[\"payment_history_table.csv\"]\n\n    # Filter both transactions and payments for the account_id (not customer_id)\n    transaction_filtered = transactions[transactions['account_id'] == row['account_id']]\n    payment_filtered = payments[payments['account_id'] == row['account_id']]\n\n    # If either dataset is empty, return 0 balance\n    if transaction_filtered.empty or payment_filtered.empty:\n        return 0\n\n    # Calculate total payments and total transactions\n    total_payments = payment_filtered['payment_amount'].sum()\n    total_transactions = transaction_filtered['transaction_amount'].sum()\n\n    # Calculate ratio (avoiding division by zero)\n    return total_payments / total_transactions if total_transactions > 0 else 0\n"
        },
        "0.013446090537023142": {
            "name": "transaction_variety",
            "code": "\n\ndef transaction_variety(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Check if 'transaction_history_table.csv' exists in aux_dataframes\n    if \"transaction_history_table.csv\" not in aux_dataframes:\n        raise KeyError(\"'transaction_history_table.csv' not found in aux_dataframes\")\n    \n    # Get the transaction history table\n    transactions = aux_dataframes[\"transaction_history_table.csv\"]\n    \n    # Filter transactions for the given account_id (not customer_id, based on the provided column names)\n    filtered = transactions[transactions['account_id'] == row['account_id']]\n    \n    # If no transactions exist for the account, return 0\n    if filtered.empty:\n        return 0\n    \n    # Return the number of unique merchant categories as a proxy for transaction variety\n    return filtered['merchant_category'].nunique()\n"
        },
        "0.003386153577008039": {
            "name": "account_utilization",
            "code": "\n\ndef account_utilization(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Ensure 'transaction_history_table.csv' exists in aux_dataframes\n    if \"transaction_history_table.csv\" not in aux_dataframes:\n        raise KeyError(\"'transaction_history_table.csv' is missing from aux_dataframes\")\n    \n    transactions = aux_dataframes[\"transaction_history_table.csv\"]\n    \n    # Ensure the required columns exist in the transactions dataframe\n    required_columns = {'account_id', 'transaction_amount'}\n    if not required_columns.issubset(transactions.columns):\n        raise KeyError(f\"The 'transaction_history_table.csv' dataframe is missing required columns: {required_columns - set(transactions.columns)}\")\n    \n    # Filter transactions by account_id\n    if 'account_id' not in row:\n        raise KeyError(\"'account_id' is missing from the input row\")\n    \n    filtered = transactions[transactions['account_id'] == row['account_id']]\n    \n    if filtered.empty:\n        return 0.0  # No transactions for this account, utilization is 0\n    \n    # Calculate total utilized amount\n    total_utilized = filtered['transaction_amount'].sum()\n    \n    # Get credit limit, defaulting to 1e6 if missing\n    credit_limit = row.get('credit_limit', 1e6)\n    \n    # Ensure credit_limit is a valid number\n    if not isinstance(credit_limit, (int, float)) or credit_limit <= 0:\n        return 0.0  # Avoid division by zero or invalid credit limit\n    \n    # Calculate and return account utilization\n    return total_utilized / credit_limit\n"
        },
        "0": {
            "name": "late_payment_frequency",
            "code": "import datetime\nimport pandas as pd\n\ndef late_payment_frequency(row, aux_dataframes: Dict[str, pd.DataFrame]):\n    # Ensure the key exists in the aux_dataframes dictionary\n    if \"payment_history_table.csv\" not in aux_dataframes:\n        raise KeyError(\"The key 'payment_history_table.csv' is missing from aux_dataframes.\")\n    \n    # Load the payment history table\n    payments = aux_dataframes[\"payment_history_table.csv\"]\n    \n    # Ensure the required columns exist in the DataFrame\n    required_columns = {'account_id', 'payment_date', 'late_payment'}\n    if not required_columns.issubset(payments.columns):\n        raise KeyError(f\"The DataFrame 'payment_history_table.csv' is missing one or more required columns: {required_columns}\")\n    \n    # Filter the payments for the specific account and late payments\n    filtered = payments[(payments['account_id'] == row['account_id']) & (payments['late_payment'] == True)]\n    \n    # If no late payments exist, return 0\n    if filtered.empty:\n        return 0\n    \n    # Calculate the total months since the earliest late payment\n    earliest_payment_date = pd.to_datetime(filtered['payment_date']).min()\n    total_months = (datetime.datetime.now() - earliest_payment_date).days / 30\n    \n    # Avoid division by zero\n    if total_months == 0:\n        return len(filtered)\n    \n    # Calculate and return the late payment frequency\n    return len(filtered) / total_months\n"
        }
    },
    "feature_descriptions": [
        "days since last marketing response",
        "avg transaction amount last 3 months",
        "avg transaction amount",
        "transaction frequency last year",
        "payment to transaction balance",
        "transaction variety",
        "account utilization",
        "late payment frequency"
    ]
}